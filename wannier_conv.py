#!/usr/bin/env python

import itertools
import numpy as np
import os
import argparse


class Hamiltonian(object):
    """
    This class contains the information of Hamiltonian generated by wannier90 code.
    All units are eV and A.

    Attributes
    ----------
    a: real-space lattice vectors in (3, 3) array.
    num_wann: the number of Wannier orbitals.
    nrpts: the number of R vectors.
    ndegen: degeneracies of Wigner-Seitz grid points in (nrpts) array.
    irvec: lattice vectors for unit cells in (nrpts, 3) array.
    ir0: index of H(R=0). If not found, return -1.
    ham_r: Wannier-based Hamiltonian in (num_wann, num_wann, nrpts) array.
    parameters:
      num_wann
      nrpts
      ndegen[1:nrpts]
      ham_r[1:num_wann,1:num_wann,1:nrpts]
      a[1:3,1:3]
      b[1:3,1:3]
    """

    def __init__(self, file_hr, reorder=False):
        """
        Parameters
        ----------
        file_hr: hr.dat file path.
        reorder: whether to reorder indices of Wannier orbitals in dat file.
        """
        self.reorder = reorder
        self._read_hr(file_hr)

    def _read_hr(self, file_hr):
        """
        Read the attributes from the given hr.dat file.
        """
        try:
            if os.path.exists(file_hr):
                fp = open(file_hr, "r")
            else:
                raise Exception
            fp.readline()   # empty line
            self.num_wann = int( fp.readline() )
            self.nrpts = int( fp.readline() )

            # print(self.num_wann, self.nrpts)

            ndegen = []
            for i in range( int(self.nrpts/15)+1 ):
                ndegen += map(int, fp.readline().split())
                if len(ndegen) >= self.nrpts: break
            self.ndegen = np.array(ndegen)

            # print(ndegen)

            self.ham_r = np.zeros((self.num_wann, self.num_wann, self.nrpts), dtype=np.complex128)
            self.irvec = np.zeros((3,self.nrpts), dtype=np.int64)

            self.ir0 = -1
            for i, m, n in itertools.product(range(self.nrpts), range(self.num_wann), range(self.num_wann)):
                (irx, iry, irz, _, _, tr, ti) = fp.readline().split()
                if m == 0 and n == 0:
                    # self.irvec[0:3,i] = np.array(map(int,[irx,iry,irz]))
                    self.irvec[0:3, i] = np.array([int(x) for x in [irx, iry, irz]])
                    if np.all(self.irvec[0:3, i] == 0):
                        self.ir0 = i
                # self.ham_r[m,n,i] = float(tr) + float(ti)*1j
                if self.reorder:
                    # VASP, wannier ver1. etc
                    mr = m // 2 + (self.num_wann // 2) * (m % 2)
                    nr = n // 2 + (self.num_wann // 2) * (n % 2)
                    self.ham_r[nr, mr, i] = float(tr) + float(ti) * 1j
                else:
                    # normal order
                    self.ham_r[n, m, i] = float(tr) + float(ti) * 1j
                    # self.ham_r[m, n, i] = float(tr) + float(ti)*1j
            fp.close()
        except Exception as e:
            print ("failed to read: " + file_hr)
            print ("type:" + str(type(e)))
            print ("args:" + str(e.args))
            print (str(e))

    def diagonalize(self, k):
        """ diagonalize H(k) and return ek, v
        """
        kr = np.dot(k, self.irvec)
        pi = np.pi
        factor = np.exp(2*pi*1j*kr)/self.ndegen
        ham = np.dot(self.ham_r, factor)
        # return np.linalg.eigh(ham)
        (e, v) = np.linalg.eigh(ham)
        # e_n v_n[i] = ham[i,j] v_n[j]:   e[n], v[j,n]
        # ham = np.dot(self.ham_r, factor)
        # correct
        # p = np.dot(ham, v) - np.einsum("i,ji->ji", e, v)
        # not correct
        # p = np.dot(ham, np.transpose(v)) - np.einsum("i,ji->ji", e, np.transpose(v))
        # for a in p:
        #    if ( sum(a * np.conjugate(a)) > 1e-9 ) : print (a)
        # return (e,v)
        return (e, v)


class Nscfout:
    """
    Nscf-Calculation must be done with "verbosity = 'high'" !
    """
    def __init__(self, nscf_out):
        with open(nscf_out, "r") as fp:
            lines = fp.readlines()
        for i, line in enumerate(lines):
            if "the Fermi energy" in line:
                self.ef = float(line[26:35])
            if "number of Kohn-Sham" in line:
                self.nbnd = int(line[35:])
            if "number of k points=" in line:
                self.nk = int(line[25:31])
                self.kp_cart = np.zeros([self.nk, 3])
                self.kp_cryst = np.zeros([self.nk, 3])
                self.wk = np.zeros([self.nk])
                for j in range(self.nk):
                    self.kp_cart[j] = np.array( [float(x) for x in lines[i+j+2][20:56].split()] )
                    self.wk[j] = float(lines[i+j+2][65:])
                    self.kp_cryst[j] = np.array( [float(x) for x in lines[i+j+4+self.nk][20:56].split()] )
        self.energy = np.zeros([self.nk, self.nbnd])
        nline, nlinemod = divmod(self.nbnd, 8)
        if(nlinemod > 0): nline += 1
        for j in range(self.nk):
            kp_str = "k =%7.4f%7.4f%7.4f" % tuple(self.kp_cart[j])
            for i, line in enumerate(lines):
                if kp_str in line:
                    tmp_list = ''.join(lines[i+2:i+2+nline]).split()
                    ene_list = []
                    for l_tmp in tmp_list:
                        len_max = 8
                        if len(l_tmp) > len_max:
                            #print(len(l_tmp),len(l_tmp)//(len_max+1))
                            [ene_list.append(l_tmp[s*(len_max+1):(s+1)*(len_max+1)]) for s in range(len(l_tmp)//(len_max+1)) ]
                        else:
                            ene_list.append(l_tmp)

                    #print(ene_list)
                    #self.energy[j, :] = [float(x) for x in ''.join(lines[i+2:i+2+nline]).split()]
                    self.energy[j, :] = [float(x) for x in ene_list]


def get_nexclude(pwscf_win):
    nexclude = 0
    with open(pwscf_win) as fp:
        for line in fp.readlines():
            if "exclude" in line:
                nexclude = int(line.split("-")[1])
                break
    return nexclude


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="check accuracy of Wannier")
    parser.add_argument("-e", type=float, default=0.0, dest="emax", help="emax")
    parser.add_argument("-o", dest="odir")
    parser.add_argument("-i", default="./check_wannier/nscf.out", dest="nscf_file")

    args = parser.parse_args()

    # Energy window for check
    emin = -200.0
    emax = args.emax #0.0
    output_dir = args.odir
    nscf_file = args.nscf_file

    nscf_data = Nscfout(nscf_file)
    nexclude = get_nexclude("./pwscf.win")
    h = Hamiltonian("./pwscf_hr.dat")


    # calculate energy difference
    delta_sum = 0
    delta_max = 0
    nek = 0
    for i in range(nscf_data.nk):
        (ek, _) = h.diagonalize(nscf_data.kp_cryst[i])

        nek_low = np.sum(ek - nscf_data.ef < emin)
        nek_max = np.sum(ek - nscf_data.ef < emax)
        if nexclude + nek_max > nscf_data.nbnd:
            nek_max = nscf_data.nbnd - nexclude
        if nek_max == nek_low:
            continue

        nek += nek_max - nek_low
        ediff = (ek[nek_low:nek_max] - nscf_data.energy[i, nexclude+nek_low:nexclude+nek_max])**2
        delta_sum += np.sum(ediff)
        delta_max = max([delta_max, np.max(ediff)])

    # output the results
    #with open("check_wannier/CONV", "w") as fp:
    with open(os.path.join(output_dir, "CONV_{}".format(emax)), "w") as fp:
        fp.write("# energy window [{:>5.2f}:{:>5.2f}]\n".format(emin, emax))
        if nek > 0:
            fp.write("average diff = {:>15.8f}\n".format(np.sqrt(delta_sum/nek)))
        else:
            fp.write("average diff = NaN")
        fp.write("max diff     = {:>15.8f}\n".format(np.sqrt(delta_max)))
